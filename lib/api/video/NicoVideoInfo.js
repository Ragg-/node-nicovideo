// Generated by CoffeeScript 1.8.0

/**
 * ニコニコ動画APIの動画情報モデルクラス
 *
 * Properties
 *   getメソッドで第１階層まで取得できます。
 *   Example: NicoVideoInfo.get("user").id
 *
 *   - id            : string    -- 動画ID
 *   - title         : string    -- 動画タイトル
 *   - description   : string    -- 動画説明文
 *   - length        : number    -- 動画の長さ（秒）
 *   - movieType     : string    -- 動画のファイル種別(mp4, flv, swf)
 *   - thumbnail     : string    -- サムネイル画像のURL
 *
 *   - count                     -- カウンタ系の情報が詰められたオブジェクト
 *       - view          : number    -- 再生数
 *       - comments      : number    -- コメント数
 *       - mylist        : number    -- マイリスト数
 *
 *   - tags          : Array     -- 動画に設定されたタグ情報の配列
 *       {name: string, isCategory: boolean, isLocked: boolean}
 *       - name          : string    -- タグ名
 *       - isCategory    : boolean   -- カテゴリタグか
 *       - isLocked      : boolean   -- ロックされているか

 *   - user                      -- 投稿者情報
 *       - id            : number    -- ユーザーID
 *       - name          : string    -- ユーザー名
 *       - icon          : string    -- ユーザーアイコンURL
 * Events
 *   - sync: (model: VideoInfo)
 *       動画情報が同期された時に発火します。
 *   - change:(model: VideoInfo, options: Object)
 *       動画情報が更新された時に発火します。
 *   - "change:[attribute]": (model: VideoInfo, value:Object, options:Object)
 *       [attribute]に指定されたプロパティが変更された時に発火します。
 *   - error:(model: VideoInfo)
 *       同期に失敗した時に発火します。
 */

(function() {
  var Backbone, Global, NicoURL, VideoInfo, request, _, _instances,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  Backbone = require("backbone");

  request = require("request");

  Global = require("utils/Global");

  NicoURL = require("../NicoURL");

  _instances = {};

  VideoInfo = (function(_super) {
    __extends(VideoInfo, _super);

    VideoInfo._cache = {};


    /**
     * オブジェクトがNicoVideoInfoのインスタンスか検証します。
     * @param {Object} obj
     */

    VideoInfo.isInstance = function(obj) {
      return obj instanceof VideoInfo;
    };

    VideoInfo.prototype.defaults = {
      title: null,
      description: null,
      length: null,
      movieType: null,
      thumbnail: null,
      isDeleted: false,
      count: {
        view: -1,
        comments: -1,
        mylist: -1
      },
      tags: [],
      user: {
        id: -1,
        name: null,
        icon: null
      }
    };

    function VideoInfo(movieId) {
      if (VideoInfo._cache[videoId] != null) {
        return VideoInfo._cache[videoId];
      }
      VideoInfo.__super__.constructor.call(this, {
        id: movieId
      });
      this.fetch();
    }

    VideoInfo.prototype.isValid = function() {
      return this.get("_isValid") === true;
    };

    VideoInfo.prototype.isDeleted = function() {
      return this.get("isDeleted");
    };

    VideoInfo.prototype.fetch = function() {
      var dfd, self;
      if (this.id == null) {
        console.error("[VideoInfo] Fetch failed. Movie id not specified.");
        return Promise.reject("Fetch failed. Movie id not specified.");
      }
      self = this;
      dfd = Promise.defer();
      request.get({
        url: NicoURL.Video.GET_VIDEO_INFO + this.id
      }, function(err, res, body) {
        if (err != null) {
          console.error("VideoInfo[id:%s]: Failed to fetch movie info.", self.id);
          if (res.statusCode === 503) {
            dfd.reject(sprintf("VideoInfo[id:%s]: Nicovideo has in maintenance.", self.id));
          } else {
            dfd.reject(err);
            self.trigger("error");
          }
          return;
        }
        self.set(self.parse(res));
        dfd.resolve();
        self.trigger("sync", self);
      });
      return dfd.promise;
    };

    VideoInfo.prototype.parse = function(res) {
      var $res, errCode, length, val;
      $res = $(res);
      length = 0;
      val = void 0;
      if ($res.find(":root").attr("status") !== "ok") {
        errCode = $res.find("error code");
        console.error("MovieInfo: 動画情報の取得に失敗しました。 (%s)", $res.find("error description"));
        return {
          isDeleted: errCode === "DELETED"
        };
      }
      $res = $res.find("thumb");
      length = (function(length) {
        var h, m, s;
        length = length.split(":");
        s = length.pop() | 0;
        m = length.pop() | 0;
        h = length.pop() | 0;
        return s + (m * 60) + (h * 3600);
      })($res.find("length").text());
      val = {
        id: $res.find("video_id").text(),
        title: $res.find("title").text(),
        description: $res.find("description").text(),
        length: length,
        movieType: $res.find("movie_type").text(),
        thumbnail: $res.find("thumbnail_url").text(),
        isDeleted: false,
        count: {
          view: $res.find("view_counter").text() | 0,
          comments: $res.find("comment_num").text() | 0,
          mylist: $res.find("mylist_counter").text() | 0
        },
        tags: _.map($res.find("tags[domain='jp'] tag"), function(tag) {
          var $t;
          $t = $(tag);
          return {
            name: $t.text(),
            isCategory: $t.attr("category") === "1",
            isLocked: $t.attr("lock") === "1"
          };
        }),
        user: {
          id: $res.find("user_id").text() | 0,
          name: $res.find("user_nickname").text(),
          icon: $res.find("user_icon_url").text()
        }
      };
      ({
        _isValid: true
      });
      return val;
    };

    VideoInfo.prototype.sync = _.noop;

    VideoInfo.prototype.save = _.noop;

    VideoInfo.prototype.destroy = _.noop;

    return VideoInfo;

  })(Backbone.Model);

  module.exports = VideoInfo;

}).call(this);
