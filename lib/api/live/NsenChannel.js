// Generated by CoffeeScript 1.8.0

/**
 * Nsenのチャンネルと対応するモデルです。
 * リクエストの送信とキャンセル、再生中の動画の取得と監視ができます。
 *
 * TODO:
 *  WaitListの取得
 *
 * Methods
 *   - getLiveInfo()         : NicoLiveInfo
 *       現在接続中の配信のNicoLiveInfoオブジェクトを取得します。
 *   - getCurrentVideo()     : VideoInfo|null
 *       現在再生中の動画情報を取得します。
 *   - getChannelType()      : string
 *       チャンネルの種別を取得します。（nsen/***の"***"の部分だけ）
 *   - isSkipRequestable()   : boolean
 *       今現在、スキップリクエストを送ることができるか検証します。
 *   - pushRequest(movie: VideoInfo)
 *       リクエストを送信します。
 *   - cancelRequest()
 *       リクエストをキャンセルします。
 *   - pushGood()
 *       Goodを送信します。
 *   - pushSkip()
 *       SkipRequestを送信します。
 *   - moveToNextLive()
 *       次の配信情報を受け取っていれば、次の配信へ移動します。
 *
 * Events
 *  - streamChanged: (newLive: NicoLiveInfo)
 *      午前４時以降、インスタンス内部で参照している放送が切り変わった時に発火します。
 *  - videochanged: (video:VideoInfo|null, beforeVideo:VideoInfo|null)
 *      再生中の動画が変わった時に発火します。
 *      第２引数に変更後の動画の情報が渡され、第３引数には変更前の動画の情報が渡されます。
 *
 *  - sendRequest:(video:VideoInfo)
 *      リクエストが完了した時に発火します。第２引数にリクエストされた動画の情報が渡されます。
 *  - cancelRequest:(video:VideoInfo)
 *      リクエストがキャンセルされた時に発火します。第２引数にキャンセルされた動画の情報が渡されます。
 *
 *  - sendGood:()
 *       Goodが送信された時に発火します。
 *  - sendSkip:()
 *       SkipRequestが送信された時に発火します。
 *
 *  - receiveGood:()
 *       誰かがGoodを送信した時に発火します。
 *  - receiveMylist:()
 *       誰かが動画をマイリストに追加した時に発火します。
 *
 *  - skipAvailable:()
$       スキップリクエストが送信可能になった時に発火します。
 *
 *  - closing: (liveId:string)
 *      午前４時くらいから送られ始める、更新リクエストを受け取った時に発火します。
 *      第２引数は移動先の放送IDです。
 *
 *  - ended:()
 *   配信が終了した時に発火します。
 */

(function() {
  var Backbone, CommentRegExp, NSEN_URL_GOOD, NSEN_URL_REQUEST, NSEN_URL_REQUEST_CANCEL, NSEN_URL_REQUEST_SYNC, NSEN_URL_SKIP, NicoLiveApi, NicoLiveInfo, NicoUrl, NicoVideoApi, NsenChannel, StringUtil, VideoInfo, cheerio, request, sprintf, _, _instances;

  _ = require("underscore");

  Backbone = require("backbone");

  NicoVideoApi = require("../video/NicoVideoApi");

  NicoLiveApi = require("../live/NicoLiveApi");

  VideoInfo = require("../video/NicoVideoInfo");

  NicoLiveInfo = require("./NicoLiveInfo");

  NicoUrl = require("../impl/NicoUrl");

  StringUtil = require("utils/StringUtil");

  cheerio = require("cheerio");

  request = require("request");

  sprintf = require("sprintf").sprintf;

  NSEN_URL_REQUEST = NicoUrl.Live.NSEN_REQUEST;

  NSEN_URL_REQUEST_CANCEL = NicoUrl.Live.NSEN_REQUEST_CANCEL;

  NSEN_URL_REQUEST_SYNC = NicoUrl.Live.NSEN_REQUEST_SYNC;

  NSEN_URL_GOOD = NicoUrl.Live.NSEN_GOOD;

  NSEN_URL_SKIP = NicoUrl.Live.NSEN_SKIP;


  /**
   * コメント種別判定パターン
   * @const {Object.<string, RegExp>
   */

  CommentRegExp = {
    good: /^\/nspanel show goodClick/i,
    mylist: /^\/nspanel show mylistClick/i,
    reset: /^\/reset (lv[0-9]*)/i,
    videoChange: /^\/play smile:((?:sm|nm)[1-9][0-9]*) main/
  };


  /**
   * 各チャンネル毎のインスタンス
   * @type {Object.<string, NsenChannel>
   */

  _instances = {};


  /**
   * Nsenチャンネルのハンドラです。
   * チャンネル上で発生するイベントを検知して通知します。
   * @constructor
   * @param {NicoLiveInfo liveInfo Nsenの配信を指すLiveInfoオブジェクト
   */

  NsenChannel = (function() {
    _["extends"](NsenChannel.prototype, Backbone.Events);


    /**
     * Nsenリクエスト時のエラーコード
     * @const {Object.<string, string>
     */

    NsenChannel.RequestErrors = {
      nsen_close: "現在リクエストを受け付けていません。",
      nsen_tag: "リクエストに必要なタグが登録されていません。",
      nsen_long: "動画が長過ぎます。",
      nsen_requested: "リクエストされたばかりです。"
    };

    NsenChannel._cache = {};


    /**
     * @private
     * @type {NicoLiveInfo}
     */

    NsenChannel.prototype._live = null;


    /**
     * @private
     * @type {CommentProvider}
     */

    NsenChannel.prototype._commentProvider = null;


    /**
     * @private
     * @type {NicoVideoApi}
     */

    NsenChannel.prototype._videoApi = null;


    /**
     * @private
     * @type {NicoLiveApi}
     */

    NsenChannel.prototype._liveApi = null;


    /**
     * @private
     * @type {NicoAuthTicket}
     */

    NsenChannel.prototype._ticket = null;


    /**
     * 再生中の動画情報
     * @private
     * @type {NicoLiveInfo}
     */

    NsenChannel.prototype._playingMovie = null;


    /**
     * 最後にリクエストした動画情報
     * @private
     * @type {VideoInfo}
     */

    NsenChannel.prototype._requestedMovie = null;


    /**
     * 最後にスキップした動画のID。
     * 比較用なので動画IDだけ。
     * @private
     * @type {string}
     */

    NsenChannel.prototype._lastSkippedMovieId = null;


    /**
     * （午前４時遷移時の）移動先の配信のID
     * @type {string}
     */

    NsenChannel.prototype._nextLiveId = null;

    NsenChannel.prototype._acceptVideoChangeDetectionFromComments = false;

    function NsenChannel(liveInfo) {
      var nsenType, self;
      if (!liveInfo instanceof NicoLiveInfo) {
        throw new Error("Passed object not instance of NicoLiveInfo.");
      }
      if (liveInfo.isNsen() === false) {
        throw new Error("This live is not Nsen live streaming.");
      }
      nsenType = liveInfo.get("stream").nsenType;
      if ((NsenChannel._cache[nsenType] != null) && (this._nextLiveId == null)) {
        return NsenChannel._cache[nsenType];
      } else {
        NsenChannel._cache[nsenType] = this;
      }
      _.bindAll(this, "_onCommentAdded", "_onLiveInfoUpdated", "_onDetectionClosing", "_onLiveClosed", "_onVideoChanged");
      this._live = liveInfo;
      this._ticket = liveInfo._getTicket();
      this._commentProvider = liveInfo.commentProvider();
      this._live.on("sync", this._onLiveInfoUpdated).on("ended", this._onLiveClosed);
      this._commentProvider.on("add", this._onCommentAdded);
      this.on("videochanged", this._onVideoChanged).on("closing", this._onDetectionClosing);
      _instances[nsenType] = this;
      self = this;
      setTimeout(function() {
        return self._acceptVideoChangeDetectionFromComments = true;
      }, 1000);
      this.fetch();
    }


    /**
     * コメントを受信した時のイベントリスナ。
     *
     * 制御コメントの中からNsen内イベントを通知するコメントを取得して
     * 関係するイベントを発火させます。
     * @param {LiveComment} comment
     */

    NsenChannel.prototype._onCommentAdded = function(comment) {
      var com, liveId, videoId;
      if (comment.isControl() || comment.isDistributorPost()) {
        com = comment.get("comment");
        if (CommentRegExp.good.test(com)) {
          this.trigger("receiveGood");
          return;
        }
        if (CommentRegExp.mylist.test(com)) {
          this.trigger("receiveMylist");
          return;
        }
        if (CommentRegExp.reset.test(com)) {
          liveId = CommentRegExp.reset.exec(com);
          if ((liveId != null ? liveId[1] : void 0) != null) {
            this.trigger("closing", liveId[1]);
          }
        }
        if (CommentRegExp.videoChange.test(com)) {
          if (this._acceptVideoChangeDetectionFromComments === true) {
            videoId = CommentRegExp.videoChange.exec(com);
            if ((videoId != null ? videoId[1] : void 0) != null) {
              return this._onVideoChangeDetected(videoId);
            }
          }
        }
      }
    };


    /**
     * 配信情報が更新された時に実行される
     * 再生中の動画などのデータを取得する
     * @param {NicoLiveInfo} live
     */

    NsenChannel.prototype._onLiveInfoUpdated = function(live) {
      var content, videoId;
      content = live.get("stream").contents[0];
      videoId = content && content.content.match(/^smile:((?:sm|nm)[1-9][0-9]*)/);
      if ((videoId != null ? videoId[1] : void 0) == null) {
        console.info("NsenChannel[%s]: Playing movie not known.", this._live.get("stream").nsenType);
        this._onVideoChangeDetected(null);
        return;
      }
      if ((this._playingMovie == null) || this._playingMovie.id !== videoId) {
        return this._onVideoChangeDetected(videoId);
      }
    };


    /**
     * 再生中の動画の変更を検知した時に呼ばれるメソッド
     * @param {string} videoId
     */

    NsenChannel.prototype._onVideoChangeDetected = function(videoId) {
      var beforeVideo, self;
      self = this;
      beforeVideo = this._playingMovie;
      if (videoId == null) {
        this.trigger("videochanged", null, beforeVideo);
        this._playingMovie = null;
        return;
      }
      return this._videoApi.getVideoInfo(videoId).then(function(video) {
        self._playingMovie = video;
        return self.trigger("videochanged", video, beforeVideo);
      });
    };


    /**
     * チャンネルの内部放送IDの変更を検知するリスナ
     * @param {string} nextLiveId
     */

    NsenChannel.prototype._onDetectionClosing = function(nextLiveId) {
      return this._nextLiveId = nextLiveId;
    };


    /**
     * 放送が終了した時のイベントリスナ
     */

    NsenChannel.prototype._onLiveClosed = function() {
      this.trigger("ended");
      return this.moveToNextLive();
    };


    /**
     * 再生中の動画が変わった時のイベントリスナ
     */

    NsenChannel.prototype._onVideoChanged = function() {
      this._lastSkippedMovieId = null;
      return this.trigger("skipAvailable");
    };


    /**
     * ニコニコ動画APIオブジェクトを取得します。
     * @private
     * @return {NicoVideoApi}
     */

    NsenChannel.prototype._getVideoApi = function() {
      if (this._videoApi == null) {
        this._videoApi = new NicoVideoApi(this._ticket);
      }
      return this._videoApi;
    };


    /**
     * 生放送APIオブジェクトを取得します。
     * @private
     * @return {NicoLiveApi}
     */

    NsenChannel.prototype._getLiveApi = function() {
      if (this._liveApi == null) {
        this._liveApi = new NicoLiveApi(this._ticket);
      }
      return this._liveApi;
    };


    /**
     * チャンネルの種類を取得します。
     * @return {string} "vocaloid", "toho"など
     */

    NsenChannel.prototype.getChannelType = function() {
      return this._live.get("stream").nsenType;
    };


    /**
     * 現在接続中の放送のNicoLiveInfoオブジェクトを取得します。
     * @return {NicoLiveInfo}
     */

    NsenChannel.prototype.getLiveInfo = function() {
      return this._live;
    };


    /**
     * 現在再生中の動画情報を取得します。
     * @return {NicoVideoInfo?}
     */

    NsenChannel.prototype.getCurrentVideo = function() {
      return this._playingMovie;
    };


    /**
     * スキップリクエストを送信可能か確認します。
     * 基本的には、sendSkipイベント、skipAvailableイベントで
     * 状態の変更を確認するようにします。
     * @return {boolean
     */

    NsenChannel.prototype.isSkipRequestable = function() {
      var video;
      video = this.getCurrentVideo();
      return (video !== null) && (this._lastSkippedMovieId !== video.id);
    };


    /**
     * サーバー側の情報とインスタンスの情報を同期します。
     * @return {Promise}
     */

    NsenChannel.prototype.fetch = function() {
      var dfd, liveId, self, url;
      if (this._live == null) {
        console.info("NsenChannel: LiveInfo not binded.");
        return Promise.reject("LiveInfo not binded.");
      }
      self = this;
      dfd = Promise.defer();
      liveId = this._live.get("stream").liveId;
      url = sprintf(NSEN_URL_REQUEST_SYNC, liveId);
      request.get({
        url: url,
        jar: this._ticket.getCookieJar()
      }, function(err, res, body) {
        var $res, videoId;
        $res = cheerio(body);
        if (err != null) {
          dfd.reject(err);
          return;
        }
        if ($res.attr("status") === "ok") {
          videoId = $res.find("id").text();
          if ((self._requestedMovie == null) || self._requestedMovie.id !== videoId) {
            return self._videoApi.getVideoInfo(videoId).then(function(movie) {
              self._requestedMovie = movie;
              self.trigger("sendRequest", movie);
              dfd.resolve();
            })["catch"](function(msg) {
              dfd.reject(msg);
            });
          }
        }
      });
      return dfd.promise;
    };


    /**
     * リクエストを送信します。
     * @param    {VideoInfo} movie
     *   リクエストする動画のVideoInfoオブジェクト
     * @return   {Promise}
     *   リクエストに成功したらresolveされます。
     *   リクエストに失敗した時、Errorオブジェクトつきでrejectされます。
     */

    NsenChannel.prototype.pushRequest = function(movie) {
      var dfd, liveId, movieId, self, url;
      if (!NicoVideoInfo.isInstance(movie)) {
        return;
      }
      self = this;
      dfd = Promise.defer();
      liveId = this._live.get("stream").liveId;
      movieId = movie.id;
      url = sprintf(NSEN_URL_REQUEST, liveId, movieId);
      request.get({
        url: url
      }, function(err, res, body) {
        var $res, errCode, reason, result;
        if (err != null) {
          console.error("NsenChannel[%s]: Failed to request pushing. (%s)", self.id, err);
          dfd.reject(sprintf("Failed to request pushing. (%s)", err));
          return;
        }
        $res = cheerio(res).find(":root");
        result = $res.attr("status") === "ok";
        if (result) {
          self._requestedMovie = movie;
          self.trigger("requested", movie);
          return dfd.resolve();
        } else {
          errCode = $res.find("error code").text();
          reason = NsenChannel.RequestErrors[errCode];
          if (reason === null) {
            reason = errCode;
          }
          return dfd.reject(reason);
        }
      });
      return dfd.promise;
    };


    /**
     * リクエストをキャンセルします
     * @return {Promise}
     *   キャンセルに成功すればresolveされます。
     *   (事前にリクエストが送信されていない場合もresolveされます。）
     *   リクエストに失敗した時、エラーメッセージつきでrejectされます。
     */

    NsenChannel.prototype.cancelRequest = function() {
      var dfr, liveId, self, url;
      if (!this._requestedMovie) {
        return Promise.reject("リクエストした動画はありません").promise;
      }
      self = this;
      dfr = Promise.defer();
      liveId = this._live.get("stream").liveId;
      url = sprintf(NSEN_URL_REQUEST_CANCEL, liveId);
      request.get({
        url: url
      }, function(err, res, body) {
        var $res;
        $res = cheerio(res);
        if (err != null) {
          console.error("");
        }
        if ($res.attr("status" === "ok")) {
          self.trigger("cancelRequest", self._requestedMovie);
          self._requestedMovie = null;
          return dfr.resolve();
        } else {
          return dfr.reject($res.find("error code").text());
        }
      });
      return dfr.promise;
    };


    /**
     * Goodを送信します。
     * @return {Promise}
     *   成功したらresolveされます。
     *   失敗した時、エラーメッセージつきでrejectされます。
     */

    NsenChannel.prototype.pushGood = function() {
      var dfr, liveId, self;
      self = this;
      dfr = Promise.defer();
      liveId = this._live.get("stream").liveId;
      request.get({
        url: sprintf(NSEN_URL_GOOD, liveId, function(err, res, body) {
          var $res, result;
          if (err != null) {
            dfr.reject(err);
          }
          $res = $(res).find(":root");
          result = $res.attr("status") === "ok";
          if (result) {
            self.trigger("sendGood");
            dfr.resolve();
          } else {
            dfr.reject($res.find("error code").text());
          }
        })
      });
      return dfr.promise;
    };


    /**
     * SkipRequestを送信します。
     * @return {Promise}
     *   成功したらresolveされます。
     *   失敗した時、エラーメッセージつきでrejectされます。
     */

    NsenChannel.prototype.pushSkip = function() {
      var dfr, liveId, movieId, self;
      self = this;
      dfr = Promise.defer();
      liveId = this._live.get("stream").liveId;
      movieId = this.getCurrentVideo().id;
      if (!this.isSkipRequestable()) {
        return Promise.reject("Skip request already sended.");
      }
      request.get({
        url: sprintf(NSEN_URL_SKIP, liveId, function(err, res, body) {
          var $res, status;
          if (err != null) {
            dfr.reject(err);
          }
          $res = $(res).find(":root");
          status = $res.attr("status") === "ok";
          if (status) {
            self._lastSkippedMovieId = movieId;
            self.trigger("sendSkip");
            return dfr.resolve();
          } else {
            return dfr.reject($res.find("error code").text());
          }
        })
      });
      return dfr.promise;
    };


    /**
     * 次のチャンネル情報を受信していれば、その配信へ移動します。
     * @return {Promise}
     *   移動に成功すればresolveされ、それ以外の時にはrejectされます。
     */

    NsenChannel.prototype.moveToNextLive = function() {
      var dfd, liveId, self;
      if (this._nextLiveId != null) {
        return Promise.reject();
      }
      self = this;
      dfd = Promise.defer();
      liveId = this._nextLiveId;
      this._getLiveApi.getLiveInfo(liveId).then(function(liveInfo) {
        self._live.off("sync", self._onLiveInfoUpdated).off("closed", self._onLiveClosed);
        self._commentProvider.off("add", self._onCommentAdded);
        (self._live != null) && self._live.dispose();
        self._live = null;
        self._commentProvider = null;
        self._live = liveInfo;
        self._commentProvider = liveInfo.getCommentProvider();
        self._live.on("sync", self._onLiveInfoUpdated).on("closed", self._onLiveClosed);
        self._commentProvider.on("add", self._onCommentAdded);
        self._nextLiveId = null;
        self.trigger("streamChanged", liveInfo);
        console.info("NsenChannel[nsne/%s]: Live stream changed", self.getChannelType());
        dfd.resolve();
        return self.fetch();
      })["catch"](function(err) {
        return dfd.reject(err);
      });
      return dfd.promise;
    };

    return NsenChannel;

  })();

  module.exports = NsenChannel;

}).call(this);
