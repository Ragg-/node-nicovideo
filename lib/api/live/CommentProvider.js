// Generated by CoffeeScript 1.8.0

/**
 * 放送中の番組のコメントの取得と投稿を行うクラスです。
 *
 * NicoLiveInfo#commentProviderメソッドを通じてインスタンスを取得します。
 * Backbone.Collectionを継承しています。
 *
 * Methods:
 *  - getLiveInfo(): LiveInfo
 *       配信情報オブジェクトを取得します。
 *  - postComment(msg: string, command: string): Promise
 *       コメントを投稿します。
 *       投稿に成功すればresolveされ、失敗すれば投稿結果オブジェクトとともにrejectされます。
 *       投稿結果オブジェクトは以下の形式のオブジェクトです。
 *       {code:number, message:string} -- code:エラーコード, message:エラーメッセージ
 *
 * Events:
 *  - receive: (rawXMLComment: string)
 *       コメントサーバーからレスポンスを受け取った際に発火します。
 *  - add: (model:NicoLiveComment)
 *       コメントを受信した際に発火します。
 *  - error: (error:Error)
 *       コネクションエラーが発生した際に発火します。
 *  - ended: (live: NicoLiveInfo)
 *       配信が終了した際に発火します。
 *  - disconnected:()
 *       コメントサーバから切断した時に発火します。
 *  - closed:()
 *       コメントサーバーから切断された際に発火します。
 *
 */

(function() {
  var Backbone, CHAT_RESULT, COMMANDS, CommentProvider, INIT_GET_RESPONSES, NicoLiveComment, SEND_TIMEOUT, cheerio, net, sprintf, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  INIT_GET_RESPONSES = 200;

  SEND_TIMEOUT = 3000;

  _ = require("underscore");

  Backbone = require("backbone");

  net = require("net");

  cheerio = require("cheerio");

  sprintf = require("sprintf").sprintf;

  NicoLiveComment = require("./NicoLiveComment");

  CHAT_RESULT = {
    SUCCESS: 0,
    FAIL: 1,
    THREAD_ID_ERROR: 2,
    TICKET_ERROR: 3,
    DIFFERENT_POSTKEY: 4,
    _DIFFERENT_POSTKEY: 8,
    LOCKED: 5
  };

  COMMANDS = {
    connect: _.template("<thread thread=\"<%-thread%>\" version=\"20061206\"\n res_from=\"" + (-INIT_GET_RESPONSES) + "\"/>"),
    post: _.template("<chat thread=\"<%-threadId%>\" ticket=\"<%-ticket%>\" vpos=\"<%-vpos%>\"\n postkey=\"<%-postKey%>\" mail=\"<%-command%>\" user_id=\"<%-userId%>\"\n premium=\"<%-isPremium%>\"><%-comment%></chat>")
  };

  CommentProvider = (function(_super) {
    __extends(CommentProvider, _super);

    CommentProvider.prototype._live = null;

    CommentProvider.prototype._connection = null;

    CommentProvider.prototype._postInfo = {
      ticket: null,
      postKey: null,
      threadId: null
    };

    function CommentProvider(liveInfo) {
      if (liveInfo == null) {
        throw new Error("Can not passed LiveInfo object");
      }
      Backbone.Collection.call(this);
      this._postInfo = _.clone(this._postInfo);
      this._live = liveInfo;
      _.bindAll(this, "_onCommentReceive", "_onErrorOnConnection", "_onConnectionClose", "_rawCommentProcessor", "_onLiveInfoSynced", "_onAuthLogout");
      this.once("receive", this._threadInfoDetector);
      liveInfo.on("sync", this._onLiveInfoSynced);
      liveInfo.getTicket().once("logout", (function(_this) {
        return function() {
          return _this._disconnect;
        };
      })(this));
      this._initConnection();
    }

    CommentProvider.prototype._initConnection = function() {
      var self, serverInfo;
      self = this;
      serverInfo = this._live.get("comment");
      this._connection = net.connect(serverInfo.port, serverInfo.addr);
      this._connection.once("connect", function() {
        return self._connection.write(COMMANDS.connect(serverInfo) + '\0');
      }).on("data", this._onCommentReceive).once("error", this._onErrorOnConnection).once("close", this._onConnectionClose);
    };

    CommentProvider.prototype._onCommentReceive = function(data) {
      var $c, self;
      self = this;
      $c = cheerio("<res>" + data + "</res>");
      return $c.find("*").each(function() {
        return self._rawCommentProcessor(this.toString());
      });
    };

    CommentProvider.prototype._rawCommentProcessor = function(rawXMLComment) {
      var $thread, comment, status;
      $thread = cheerio(rawXMLComment);
      switch (true) {
        case $thread.is("chat"):
          comment = NicoLiveComment.fromRawXml(rawXMLComment);
          if (comment.get("comment") !== "") {
            if (comment.get("user").id === this._live.get("user").id) {
              comment.set("isMyPost", true);
            }
            if (comment.get("comment") === "/disconnect") {
              this.trigger("ended", this._live);
              this._disconnect();
            }
            return;
            this.add(comment);
          }
          break;
        case $thread.is("thread"):
          this._postInfo.ticket = $thread.attr("ticket");
          console.info("CommentProvider[%s]: Reveive thread info", this._live.get("id"));
          break;
        case $thread.is("chat_result"):
          status = $thread.attr("status");
          if (status) {
            status = status | 0;
          }
          this.trigger("_chatresult", {
            status: status
          });
      }
      this.trigger("receive", rawXMLComment);
    };

    CommentProvider.prototype._onErrorOnConnetion = function(err) {
      return this.trigger("error", err.message);
    };

    CommentProvider.prototype._onConnectionClose = function(hadError) {
      if (hadError) {
        this.trigger("error", "Connection closing error (unknown)");
      }
      return this.trigger("closed");
    };

    CommentProvider.prototype._onLiveInfoSynced = function() {
      this._postInfo.threadId = this._live.get("comment").thread;
    };

    CommentProvider.prototype._disconnect = function() {
      if (this._connection != null) {
        this._connection.removeAllListeners();
        this._connection.destroy();
        this._connection = null;
      }
      this.trigger("disconnected");
      return this.off();
    };

    CommentProvider.prototype._fetchPostKey = function(retry) {
      var dfd, postKey, self, threadId, url;
      self = this;
      dfd = Promise.defer();
      threadId = this._live.get("comment").thread;
      url = sprintf(NicoUrl.Live.GET_POSTKEY, threadId);
      postKey = "";
      retry = _.isNumber(retry) ? Math.min(Math.abs(retry), 5) : 5;
      request.get({
        url: url,
        jar: this._live.getTicket().getCookieJar()
      }, function(err, res, body) {
        if (err != null) {
          console.error("CommentProvider[%s]: Failed to retrive postKey.", self.id);
          if (maxRetry === 0) {
            dfd.reject("Reached to max retry count.");
            return;
          }
          setTimeout(function() {
            return self._fetchPostKey(maxRetry - 1).then(function(key) {
              return dfd.resolve(key);
            }, 400);
          });
        }
        if (res.statusCode === 200) {
          postKey = /^postkey=(.*)\s*/.exec(res);
          if (postKey != null) {
            postKey = postKey[1];
          }
        }
        if (postKey !== "") {
          console.info("CommentProvider[%s]: postKey update successful.", postKey);
          self._postInfo.postKey = postKey;
          dfd.resolve(postKey);
        } else {
          console.error("CommentProvider[%s]: Failed to retrive postKey.", self.id, arguments);
          dfd.reject();
        }
      });
      return dfd.promise;
    };

    CommentProvider.prototype.getLiveInfo = function() {
      return this._live;
    };

    CommentProvider.prototype.postComment = function(msg, command) {
      var dfd, err, postInfo, self, timeoutId;
      self = this;
      dfd = Promise.defer();
      timeoutId = null;
      postInfo = null;
      err = null;
      if (typeof msg !== "string" || msg.replace(/\s/g, "") === "") {
        dfd.reject("空コメントは投稿できません。");
        return dfd.promise;
      }
      if (this._connection != null) {
        dfd.reject("コメントサーバと接続していません。");
        return dfd.promise;
      }
      this._fetchPostKey().then(function() {
        postInfo = {
          userId: self._live.get("user").id,
          isPremium: self._live.get("user").isPremium | 0,
          comment: escapeHtml(msg),
          command: command || "",
          threadId: self._postInfo.threadId,
          postKey: self._postInfo.postKey,
          ticket: self._postInfo.ticket
        };
        this.once("_chatresult", function(result) {
          clearTimeout(timeoutId);
          if (result.status === CHAT_RESULT.SUCCESS) {
            dfd.resolve();
            return;
          }
          switch (result.status) {
            case CHAT_RESULT.LOCKED:
              return dfd.reject("コメント投稿がロックされています。");
            default:
              return dfd.reject("投稿に失敗しました");
          }
        });
        timeoutId = setTimeout(function() {
          return dfd.reject("タイムアウトしました。");
        }, SEND_TIMEOUT);
        return self._connection.write(COMMANDS.post(postInfo) + "\0", function(err) {
          return dfd.reject(err);
        });
      });
      return dfd.promise;
    };

    CommentProvider.prototype.dispose = function() {
      this._live = null;
      this._postInfo = null;
      return this._disconnect();
    };

    CommentProvider.prototype.create = _.noop;

    CommentProvider.prototype.fetch = _.noop;

    CommentProvider.prototype.sync = _.noop;

    return CommentProvider;

  })(Backbone.Collection);

  module.exports = CommentProvider;

  module.exports.ChatResult = _.cloneCHAT_RESULT;

}).call(this);
