// Generated by CoffeeScript 1.8.0
(function() {
  var Backbone, CommentProvider, NicoLiveInfo, NicoURL, UPDATE_INTERVAL, cheerio, defaultVal, request, sprintf, _, _updateEventer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  Backbone = require("backbone");

  request = require("request");

  sprintf = require("sprintf").sprintf;

  cheerio = require("cheerio");

  CommentProvider = require("./CommentProvider");

  NicoURL = require("../NicoURL");

  UPDATE_INTERVAL = 10000;

  _updateEventer = _.extend({}, Backbone.Events);


  /**
   * valがnullもしくはundefinedの時にdefを返します。
   *
   * @param {Object} val
   * @param {Object} def
   * @return {Object}
   */

  defaultVal = function(val, def) {
    if (val != null) {
      return val;
    } else {
      return def;
    }
  };

  setInterval(function() {
    return _updateEventer.trigger("intervalSync");
  }, UPDATE_INTERVAL);

  NicoLiveInfo = (function(_super) {
    __extends(NicoLiveInfo, _super);

    NicoLiveInfo._cache = {};

    NicoLiveInfo.prototype._commentProvider = null;

    NicoLiveInfo.prototype._ticket = null;

    NicoLiveInfo.prototype.defaults = {
      stream: {
        liveId: null,
        title: null,
        description: null,
        watchCount: -1,
        commentCount: -1,
        baseTime: null,
        openTime: null,
        startTime: null,
        endTime: null,
        isOfficial: false,
        isNsen: false,
        nsenType: null,
        contents: {}
      },
      owner: {
        userId: -1,
        name: null
      },
      user: {
        id: -1,
        name: null,
        isPremium: null
      },
      rtmp: {
        isFms: null,
        port: null,
        url: null,
        ticket: null
      },
      comment: {
        addr: null,
        port: -1,
        thread: null
      },
      _hasError: true
    };


    /**
     * @param {NicoAuthTicket}   ticket  認証チケット
     * @param {string}           liveId  放送ID
     */

    function NicoLiveInfo(ticket, liveId) {
      if (NicoLiveInfo._cache[liveId] != null) {
        return _instances[liveId];
      }
      NicoLiveInfo.__super__.constructor.call(this, {
        id: liveId
      });
      this._ticket = ticket;
      _.bindAll(this, "_autoUpdate", "_onClosed");
      _updateEventer.on("intervalSync", _onIntervalSync);
      NicoLiveInfo._cache[liveId] = this;
    }


    /**
     * 自動更新イベントのリスナ
     * @private
     */

    NicoLiveInfo.prototype._onIntervalSync = function() {
      var e;
      try {
        return this.fetch();
      } catch (_error) {
        e = _error;
        return console.error(e.message);
      }
    };


    /**
     * 配信終了イベントのリスナ
     * @private
     */

    NicoLiveInfo.prototype._onClosed = function() {
      this.trigger("ended");
      return _dispose(this);
    };

    NicoLiveInfo.prototype.isValid = function() {
      return !this.get("_hasError");
    };

    NicoLiveInfo.prototype.isOfficial = function() {
      return !!this.get("stream").isOfficial;
    };

    NicoLiveInfo.prototype.isNsen = function() {
      return !!this.get("stream").isNsen;
    };

    NicoLiveInfo.prototype.isEnded = function() {
      return this.get("isEnded") === true;
    };

    NicoLiveInfo.prototype.getTicket = function() {
      return this._ticket;
    };

    NicoLiveInfo.prototype.commentProvider = function() {
      if (!this._commentProvider) {
        this._commentProvider = new CommentProvider(this);
      }
      return this._commentProvider;
    };


    /**
     * APIから取得した情報をパースします。
     * @private
     * @param {string} res API受信結果
     */

    NicoLiveInfo.prototype.parse = function(res) {
      var $ms, $res, $root, $rtmp, $stream, $user, msg, val;
      $res = cheerio(res);
      $root = $res.find(":root");
      $stream = $res.find("stream");
      $user = $res.find("user");
      $rtmp = $res.find("rtmp");
      $ms = $res.find("ms");
      val = null;
      if ($root.attr("status") !== "ok") {
        msg = $res.find("error code").text();
        console.error("NicoLiveInfo[%s]: Failed live info fetch. (%s)", this.id, msg);
        this.trigger("error", msg, this);
        return {
          _hasError: true
        };
      }
      val = {
        stream: {
          liveId: $stream.find("id").text(),
          title: $stream.find("title").text(),
          description: $stream.find("description").text(),
          watchCount: $stream.find("watch_count").text() | 0,
          commentCount: $stream.find("comment_count") | 0,
          baseTime: new Date(($stream.find("base_time").text() | 0) * 1000),
          openTime: new Date(($stream.find("open_time").text() | 0) * 1000),
          startTime: new Date(($stream.find("start_time").text() | 0) * 1000),
          endTime: new Date(($stream.find("end_time") | 0) * 1000),
          isOfficial: $stream.find("provider_type").text() === "official",
          isNsen: $res.find("ns").length > 0,
          nsenType: $res.find("ns nstype").text() || null,
          contents: _.map($stream.find("contents_list contents"), function(content) {
            var $content;
            $content = cheerio(content);
            return {
              id: $content.attr("id"),
              startTime: new Date(($content.attr("start_time") | 0) * 1000),
              disableAudio: ($content.attr("disableAudio") | 0) !== 1,
              disableVideo: ($content.attr("disableVideo") | 0) !== 1,
              duration: defaultVal($content.attr("duration"), null) | 0,
              title: defaultVal($content.attr("title"), null),
              content: $content.text()
            };
          })
        },
        owner: {
          userId: $stream.find("owner_id").text() | 0,
          name: $stream.find("owner_name").text()
        },
        user: {
          id: $user.find("user_id").text() | 0,
          name: $user.find("nickname").text(),
          isPremium: $user.find("is_premium").text() === "1"
        },
        rtmp: {
          isFms: $rtmp.attr("is_fms") === "1",
          port: $rtmp.attr("rtmpt_port") | 0,
          url: $rtmp.find("url").text(),
          ticket: $rtmp.find("ticket").text()
        },
        comment: {
          addr: $ms.find("addr").text(),
          port: $ms.find("port").text() | 0,
          thread: $ms.find("thread").text() | 0
        },
        _hasError: $res.find("getplayerstatus").attr("status") !== "ok"
      };
      return val;
    };


    /**
     * 番組情報を最新の状態に同期します。
     * @return {Promise}
     */

    NicoLiveInfo.prototype.fetch = function() {
      var dfd, self, url;
      if (this.id === null) {
        return Promise.reject("Live id not specified.");
      }
      self = this;
      dfd = Promise.defer();
      url = sprintf(NicoURL.Live.GET_PLAYER_STATUS, this.id);
      request.get({
        url: url,
        jar: this._ticket.getCookieJar()
      }, function(err, res, body) {
        if ((err != null) && res.statusCode === 503) {
          err = sprintf("NicoLiveInfo[%s]: Nicovideo has in maintenance.", self.id);
        }
        if (err) {
          console.error("NicoLiveInfo[%s]: Failed live info fetch. (%s)", self.id, err);
          self.trigger("error", err, self);
          dfd.reject(err);
          return;
        }
        if (!self.set(self.parse(body))) {
          return false;
        }
        if (self._commentProvider == null) {
          self._commentProvider = new CommentProvider(self);
          self._commentProvider.on("ended", self._onClosed);
        }
        self.trigger("sync");
        return dfd.resolve();
      });
      return dfd.promise;
    };

    NicoLiveInfo.prototype.destroy = function() {
      var requireKeep;
      requireKeep = false;
      this.trigger("beforeDestroy", function() {
        return requireKeep = true;
      });
      if (requireKeep === false) {
        _updateEventer.off("intervalSync", this._onIntervalSync);
        this.off();
        this._commentProvider.dispose();
        this._commentProvider = void 0;
        this.set("isEnded", true);
        return delete NicoLiveInfo._cache[this.id];
      }
    };

    NicoLiveInfo.prototype.dispose = function() {
      return this.destroy();
    };

    NicoLiveInfo.prototype.sync = _.noop;

    NicoLiveInfo.prototype.save = _.noop;

    return NicoLiveInfo;

  })(Backbone.Model);

  module.exports = NicoLiveInfo;

}).call(this);
